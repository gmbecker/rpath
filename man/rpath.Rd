% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Rpath.R
\name{rpath}
\alias{rpath}
\title{Rpath 'language spec'}
\usage{
rpath(
  robj,
  path,
  state = new.env(),
  default_ns = "nm",
  ns_funcs = nsFuncs,
  term_condition = list_termination,
  default_as = names(as_funcs)[1],
  as_funcs = asFuncs
)
}
\arguments{
\item{robj}{Object to match against}

\item{path}{A character value containing the rpath expression}

\item{state}{an environment, used internally to track state}

\item{default_ns}{Namespace to use when no-namespace is specified. Defaults to \code{nm} for names.}

\item{term_condition}{function. Function returning true if maximum depth has been reached (ie no more recursion should be done).}

\item{default_as}{character. Attribute space to use when none is specified. Defaults to the name of the first element in \code{as_funcs} (which defaults to \code{a} indicating R attributes when \code{as_funcs} is not specified). .}

\item{as_funcs}{list. Named list of functions to resolve path attributes of different types (ie different attribute spaces). Defaults to standard R attributes, namespaced as "a".}
}
\description{
"namespace" indicates how to resolve names, e.g. cl:numeric means elements with (first) class "numeric" match, nm:hi means elements with name (as returned by names() ) "hi" match.
default, namespaceless node 'name' resolution is controlled by names_fun
Attributes (@) are controlled by the "attributespace", indicated by '~', i.e. nodename@ar~dim would resolve via attrib, while nodename@sl~data would resolve as an S4 slot.
default, attributespaceless attributes resolution is controlled by attr_fun
predicates are indicated via [] as in XPath, they can be indexes (including support for vectors of indexs via nodename[x:y] ), rpath expressions, or logical operations
equality in predicates uses "==", as in R
Axes other than / and // (eg parent, ancestor) are not supported, as most R objects are unable to point to their parent object
Wildcard (matches everything) is indicated by '*', as in /numeric/* will return all elements of the vector
The 'and' and 'or' operators are indicated by & and | respectively, as in their vectorized forms in R
Terminal nodes are recognized via the term_condition argument. This is necessary because in R, you can infinitely subset a vector of length one via v[1][1][1] etc.
}
\examples{

lst = list(first = TRUE, second = FALSE, third = list(fourth = 5, fifth = "hi"), sixth = "SO FUNNY!!!")

rpath(lst, "/third")

rpath(lst, "/third/fourth")

rpath(lst, "/*[fourth]")
rpath(lst, "/*")
rpath(lst, "/third/*")

rpath(lst, "/third[fourth]")

rpath(lst, "/cl:logical")
rpath(lst, "/cl:list")
rpath(lst, "/cl:list/cl:character")

rpath(lst, "//fourth")
rpath(lst, "/*/fourth")
rpath(lst, "//third")

rpath(lst, "//cl:logical")
rpath(lst, "//cl:character")

lst2 = c(lst, lst)

rpath(lst2, "/third")
rpath(lst2, "/third/fourth")

rpath(lst2, "/third[1]/fourth")

rpath(lst2, "/third[1]")
}
